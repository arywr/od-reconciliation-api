// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: reconcile_rule.sql

package db

import (
	"context"
)

const getReconcileRule = `-- name: GetReconcileRule :many
SELECT id, product_id, platform_id, product_column_field, product_column_conditions, product_column_value, platform_column_field, platform_column_conditions, platform_column_value, rule_mandatory, created_at, updated_at, deleted_at
FROM reconcile_rules
WHERE product_id = $1
AND platform_id = $2
`

type GetReconcileRuleParams struct {
	ProductID  int64 `json:"product_id"`
	PlatformID int64 `json:"platform_id"`
}

func (q *Queries) GetReconcileRule(ctx context.Context, arg GetReconcileRuleParams) ([]ReconcileRule, error) {
	rows, err := q.db.QueryContext(ctx, getReconcileRule, arg.ProductID, arg.PlatformID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ReconcileRule{}
	for rows.Next() {
		var i ReconcileRule
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.PlatformID,
			&i.ProductColumnField,
			&i.ProductColumnConditions,
			&i.ProductColumnValue,
			&i.PlatformColumnField,
			&i.PlatformColumnConditions,
			&i.PlatformColumnValue,
			&i.RuleMandatory,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
